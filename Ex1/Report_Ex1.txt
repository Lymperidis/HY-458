/*CSD4813 Lymperidis Lymperis */

Αναφορα Σειρα ασκησεων 1 ;

A)(plaintext)

1)To Πρωτο txt has 198.476 και βρηκα και ποσες φορες εμφανιζεται το καθε γραμμα
μεσα στο αρχειο. Τα τυπωσα σε ενα CSV file.

2)To Δευτερο txt has 584.223 και βρηκα και ποσες φορες εμφανιζεται το καθε γραμμα
μεσα στο αρχειο. Τα τυπωσα σε ενα CSV file.


3)To Τριτο txt has 230.661 και βρηκα και ποσες φορες εμφανιζεται το καθε γραμμα
μεσα στο αρχειο. Τα τυπωσα σε ενα CSV file.

B)(Encrypt Algorithms Explanation)

Polybius Square : Καθε γράμμα αντικαθήστατε με 2 νουμερα που λενε την σειρα
και την στηλη ενος πινακα . 

Caeser (ROT=13) : Καθε γραμμα αντικαθήστατε με ενα γραμμα της αλφαβητου 
με shift οσο ειναι το ROT π.χ.(ROT=7 . A - > Θ).

Monoalphabetic (Atbash) : Η αλφαβητος αντιστρεφεται (π.χ. Α- > Ζ, Β - >Υ) πραγμα που μπορει να γινει
brute force αρκετα ευκολα.

Homophonic : Αυτος ο τροπος κρυπτογραφησης παιρνει ενα συμβολο απο το
plaintext και μπορει να ανιτστοιχει σε ενα ή περισσοτερα συμβολα στο cypher text
πραγμα που το κανει πιο δυσκολο να γινει brute force γιατι μπορει να μην ειναι παντα
ιδιο το cyphertext , πιθανως συμβολα τα οποια υπαρχουν συχνα στο plain text μπορουν να εχουμ
διαφορετικο representation μεσα στο cypher text.


Book : Αυτος τωρα ο τροπος για να αποκρυπτογραφισει καποιος αυτο το text 
θα χρειαστει να ξερει το key_book δηλαδη απο ποιο βιβλιο εχει γινει το encodemenet
καθως στελνει την γραμμη - την λεξη - τον χαρακτηρα μεσα σε ενα βιβλιο (π.χ. 3-1-2 δηλαδη 3η γραμμη
1η λεξη 2ο χαρακτηρα).Πραγμα που ειναι ακομα πιο δυσκολο να γινει brute force 

Playfair : Αυτος ο τροπος αποκρυπτογραφισεις εχει να κανει με αντικατασταση. Δηλαδη πρωτα φτιαχνεις το
key square 5x5 περνοντας ενα keyword το οποιο πρεπει σαν να λεξη να μην
επαναλαμβανει κανενα γραμμα της αλφαβητου (π.χ. keyword) μετα βαζεις τα υπολοιπα
γραμματα . Για καθε ζευγαρι γραμματων του plaintext υπαρχουν διαφοροι τροποι 
κρυπτογραγησης αναλογα με το που βρισκονται αυτα τα δυο γραμματα(ιδια γραμμη,ιδια στηλη , κανενα απο τα δυο)
Ειναι πολυ δυσκολο να λυθει με brute force καθως δεν ξερεις το keyword για να μπορεις να αποκρυπτογραφισεις.

Polyalphabetic(Vigenere) : Αυτος ο τροπος ειναι μια εξελιξη του monoalphabetic 
καθως το καθε γραμμα του keyword δειχνει shift values . Το keyword πρεπει να ειναι οσο το 
plaintext και αν δεν ειναι τοτε επαναλαμβανεται μεχρι καθε χαρακτηρας του keyword να ταιριζει με εναν
του plaintext (Π.χ. plaintext :Hello ; Keyword = Key τοτε Keyword=keyke). Τωρα καθε γραμμα του 
keyword δειχνει ποσo φορες θα κανει shift με το γραμμα που ταιριζει στο plaintext. Παραδειγμα,
A -> 0 φορες Β-> 1 φορα Γ-> 2 φορες αρα Hello(keyword = keyke) - > 

H -> 7     	H + K = 7 + 10 = 17 -> R
Ε -> 4		E + E = 4 + 4 = 8 -> I
L -> 11		L + Y = 11 + 24 = 35 (mod 26) = 9 -> J
L -> 11		L + K = 11 + 10 = 21 -> V
Ο -> 14		O + E = 14 + 4 = 18 -> S	

Γενικα ο τροπος αυτος ειναι ακομα πιο δυσκολος να γινει brute force ή να αναλυθει απο το
frequency analysis και αλλες τροπος cryptanalysis. Παρολαυτα το το cyphertext μπορει να 
σπασει αν μαντεψει καποιος το κλειδι ή προκαθωρισμενο.

Running-Key : Σε αυτον τον αλγοριθμο υπαρχουν ενα plain text και ενα keyword 
το keyword μπορει να ειναι random και παιζει σημαντικο ρολο . Τωρα τροποποιουμαι 
τους χαρακτηρες του plain text στα αριθμητικα τους νουμερα(Α->0,Β->1,Γ->3 ,οπως και το keyword .
Μετα κανουμε μαθηματικες πραξεις (προσθεση ή αφαιρεση) για να βρουμε με ποιο γραμμα 
της αλφαβητου ταιριαζει (6->Ζ κτλ). Αυτος ο αλγοριθμος βασιζεται στην τυχαια δημιουργια 
του keyword και ποσο κρυφος θα ειναι. Ειναι ενας αλγοριθμος 
ο οποιος ειναι γενικα πολυ δυσκολος να σπασεις . 


Auto-Key: Αυτος ο αλγοριθμος ειναι αλγοριθμος αντικαταστασης . Διαλεγουμε ενα keyphrase 
το οποιο πρεπει να ειναι ιδιο μηκος με το Plaintext, αν δεν ειναι απλα επαναλμβανουμε το 
keyphrase μεχρι να ειναι το ιδιο μηκος. Τωρα με απλη αντικατασταση οπως ενα shift μπροστα
ή πισω στην αλφαβητα δημιουργουμε το encryption . Ο αλγοριθμος αυτος δεν θεωρειται πολυ
ασφαλης καθως διαφοροι τροποι αποκρυπτογραφησης και frequency analysis "σπανε" ευκολα 
αυτο τον τροπο αποκρυπτογραφησης.

One-Time Pad: Αυτος ο αλγοριθμος θεωρητικα ειναι απιθανο να αποκρυπτογραφηθει ,ακομα και πληρη υπολογιστικη ισχυει
εφοσον παντα βεβαια το κλειδι χρησιμοποιηθει μια φορα και ειναι μυστικο. Το κλειδι μαζι
με το Plain text και μετατρεπεις και τα δυο σε binary αριθμους και τους περνας απο ΧΟR
δηλαδη σου βγαζει ενα το υπολοιπο απο την αφαιρεση .
Παραδειγμα. 

Message: HELLO
One-Time Pad: XMCKL

Encryption:
H (72 in ASCII) XOR X (88 in ASCII) = 16 in binary
E (69 in ASCII) XOR M (77 in ASCII) = 6 in binary
L (76 in ASCII) XOR C (67 in ASCII) = 11 in binary
L (76 in ASCII) XOR K (75 in ASCII) = 3 in binary
O (79 in ASCII) XOR L (76 in ASCII) = 3 in binary

The encrypted message in binary is: 16 6 11 3 3.

Γενικα αυτος ο αλγοριθμος δεν χρησιμοποιηται στην πραξη αλλα ειναι ενα πολυ ενδιαφερον 
θεωρητικο concept.

Frequency Distribution Cyphertext : 

Ολα τα αποτελεσμτα(27) υπαρχουν στον φακελο Frequency Distribution.(OTP cyphertext 
δεν υπαρχει καθως δεν μπορουσα να να ανοιξω το output file )


Cypher Text graphs : Στο directory CypherText_Freq_Analysis_Graphs

Cypher Text : Στο directory CypherText

 



	
		   


   